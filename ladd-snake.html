<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ladd Snake</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Roboto:wght@400;500;700&display=swap');
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            user-select: none;
            -webkit-user-select: none;
        }

        body {
            font-family: 'Roboto', sans-serif;
            background: #0a0a0a;
            background-image: 
                radial-gradient(circle at 20% 50%, rgba(10, 30, 50, 0.3) 0%, transparent 50%),
                radial-gradient(circle at 80% 80%, rgba(20, 40, 60, 0.3) 0%, transparent 50%),
                radial-gradient(circle at 40% 20%, rgba(15, 35, 55, 0.2) 0%, transparent 50%),
                linear-gradient(to bottom, #0a1a2e 0%, #16213e 50%, #0f1b2e 100%);
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            overflow: hidden;
            position: relative;
        }

        body::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-image: 
                repeating-linear-gradient(0deg, rgba(255,255,255,0.03) 0px, transparent 1px, transparent 2px, rgba(255,255,255,0.03) 3px),
                repeating-linear-gradient(90deg, rgba(255,255,255,0.03) 0px, transparent 1px, transparent 2px, rgba(255,255,255,0.03) 3px);
            pointer-events: none;
            z-index: 1;
        }

        #gameContainer {
            text-align: center;
            position: relative;
            z-index: 2;
        }

        #gameTitle {
            font-size: 32px;
            font-weight: 700;
            color: #fff;
            text-shadow: 0 0 20px rgba(138, 180, 248, 0.6), 0 4px 8px rgba(0,0,0,0.9);
            background: linear-gradient(to bottom, rgba(26, 26, 26, 0.8), rgba(20, 20, 20, 0.8));
            padding: 16px 40px;
            border-radius: 12px;
            border: 3px solid rgba(74, 126, 168, 0.5);
            box-shadow: 0 4px 12px rgba(0,0,0,0.5);
            margin-bottom: 20px;
        }

        #scoreBoard {
            display: flex;
            justify-content: space-around;
            margin-bottom: 15px;
            padding: 15px;
            background: linear-gradient(to bottom, rgba(26, 26, 26, 0.95) 0%, rgba(20, 20, 20, 0.95) 100%);
            background-image: 
                repeating-linear-gradient(0deg, rgba(255,255,255,0.02) 0px, transparent 1px, transparent 2px),
                repeating-linear-gradient(90deg, rgba(255,255,255,0.02) 0px, transparent 1px, transparent 2px);
            border-radius: 8px;
            border: 1px solid rgba(42, 42, 42, 0.8);
            box-shadow: inset 0 0 30px rgba(0,0,0,0.5);
        }

        .scoreItem {
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .scoreLabel {
            font-size: 11px;
            color: #aaa;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 5px;
            font-weight: 500;
        }

        .scoreValue {
            font-size: 28px;
            font-weight: 700;
            color: #8ab4f8;
            text-shadow: 0 0 8px rgba(138, 180, 248, 0.3);
        }

        #gameCanvas {
            border: 2px solid #2a2a2a;
            border-radius: 4px;
            box-shadow: 0 4px 16px rgba(0,0,0,0.5), inset 0 0 30px rgba(0,0,0,0.3);
            background: #0f0f0f;
            display: block;
            margin: 0 auto;
        }

        #gameOverScreen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            backdrop-filter: blur(8px);
        }

        #gameOverContent {
            background: linear-gradient(to bottom, rgba(26, 26, 26, 0.98) 0%, rgba(20, 20, 20, 0.98) 100%);
            background-image: 
                repeating-linear-gradient(0deg, rgba(255,255,255,0.02) 0px, transparent 1px, transparent 2px),
                repeating-linear-gradient(90deg, rgba(255,255,255,0.02) 0px, transparent 1px, transparent 2px);
            padding: 40px 60px;
            border-radius: 12px;
            border: 2px solid rgba(74, 126, 168, 0.5);
            text-align: center;
            box-shadow: 0 12px 48px rgba(0,0,0,0.8), inset 0 0 30px rgba(0,0,0,0.5);
            animation: popIn 0.3s ease-out;
        }

        @keyframes popIn {
            0% {
                transform: scale(0.8);
                opacity: 0;
            }
            100% {
                transform: scale(1);
                opacity: 1;
            }
        }

        #gameOverTitle {
            font-size: 48px;
            font-weight: 700;
            color: #fff;
            margin-bottom: 20px;
            text-shadow: 0 0 20px rgba(138, 180, 248, 0.6), 0 4px 8px rgba(0,0,0,0.9);
        }

        #finalScore {
            font-size: 20px;
            color: #ccc;
            margin-bottom: 8px;
        }

        #finalScore span {
            color: #8ab4f8;
            font-weight: 700;
            font-size: 24px;
        }

        #highScoreDisplay {
            font-size: 18px;
            color: #999;
            margin-bottom: 30px;
        }

        #highScoreDisplay span {
            color: #8ab4f8;
            font-weight: 700;
        }

        #restartButton {
            cursor: pointer;
            border: 3px solid #000;
            background-color: #264f78;
            padding: 0;
            padding-bottom: 8px;
            transition: 0.1s ease-in-out;
            margin-top: 10px;
        }

        #restartButton:hover {
            background-color: #2d5a88;
        }

        .button-inner {
            background: linear-gradient(to bottom, #264f78 0%, #1e3f5f 100%);
            border: 3px solid #3a6ea5;
            padding: 12px 32px;
            font-size: 18px;
            font-weight: 700;
            color: #fff;
            pointer-events: none;
        }

        #restartButton:active {
            padding-bottom: 0 !important;
            transform: translateY(8px);
        }

        #instructions {
            margin-top: 20px;
            padding: 15px;
            background: linear-gradient(to bottom, rgba(26, 26, 26, 0.95) 0%, rgba(20, 20, 20, 0.95) 100%);
            background-image: 
                repeating-linear-gradient(0deg, rgba(255,255,255,0.02) 0px, transparent 1px, transparent 2px),
                repeating-linear-gradient(90deg, rgba(255,255,255,0.02) 0px, transparent 1px, transparent 2px);
            border-radius: 8px;
            border: 1px solid rgba(42, 42, 42, 0.8);
            box-shadow: inset 0 0 30px rgba(0,0,0,0.5);
            color: #ccc;
            font-size: 14px;
        }

        #instructions strong {
            color: #8ab4f8;
        }

        #leaderboardButton {
            cursor: pointer;
            border: 3px solid #000;
            background-color: #264f78;
            padding: 0;
            padding-bottom: 6px;
            transition: 0.1s ease-in-out;
            margin-top: 15px;
        }

        #leaderboardButton:hover {
            background-color: #2d5a88;
        }

        #leaderboardButton:active {
            padding-bottom: 0 !important;
            transform: translateY(6px);
        }

        #leaderboardScreen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            backdrop-filter: blur(8px);
        }

        #leaderboardContent {
            background: linear-gradient(to bottom, rgba(26, 26, 26, 0.98) 0%, rgba(20, 20, 20, 0.98) 100%);
            background-image: 
                repeating-linear-gradient(0deg, rgba(255,255,255,0.02) 0px, transparent 1px, transparent 2px),
                repeating-linear-gradient(90deg, rgba(255,255,255,0.02) 0px, transparent 1px, transparent 2px);
            padding: 40px 50px;
            border-radius: 12px;
            border: 2px solid rgba(74, 126, 168, 0.5);
            text-align: center;
            box-shadow: 0 12px 48px rgba(0,0,0,0.8), inset 0 0 30px rgba(0,0,0,0.5);
            animation: popIn 0.3s ease-out;
            max-width: 500px;
            width: 90%;
        }

        #leaderboardTitle {
            font-size: 36px;
            font-weight: 700;
            color: #fff;
            margin-bottom: 25px;
            text-shadow: 0 0 20px rgba(138, 180, 248, 0.6), 0 4px 8px rgba(0,0,0,0.9);
        }

        #leaderboardList {
            margin-bottom: 25px;
            text-align: left;
        }

        .leaderboardEntry {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 12px 15px;
            margin: 6px 0;
            background: linear-gradient(to bottom, rgba(42, 42, 42, 0.5), rgba(32, 32, 32, 0.5));
            border: 1px solid rgba(74, 126, 168, 0.3);
            border-radius: 6px;
            transition: all 0.2s;
        }

        .leaderboardEntry:hover {
            background: linear-gradient(to bottom, rgba(52, 52, 52, 0.6), rgba(42, 42, 42, 0.6));
            border-color: rgba(74, 126, 168, 0.5);
        }

        .leaderboardEntry.top3 {
            border-color: #ffd700;
            background: linear-gradient(to bottom, rgba(80, 60, 20, 0.4), rgba(60, 40, 10, 0.4));
        }

        .leaderboardEntry.currentPlayer {
            border-color: #4CAF50;
            box-shadow: 0 0 12px rgba(76, 175, 80, 0.4);
        }

        .leaderboardRank {
            font-size: 20px;
            font-weight: 700;
            color: #8ab4f8;
            width: 40px;
        }

        .leaderboardEntry.top3 .leaderboardRank {
            color: #ffd700;
            font-size: 24px;
        }

        .leaderboardName {
            flex: 1;
            font-size: 16px;
            color: #ccc;
            padding: 0 15px;
        }

        .leaderboardScore {
            font-size: 18px;
            font-weight: 700;
            color: #8ab4f8;
        }

        #closeLeaderboardButton {
            cursor: pointer;
            border: 3px solid #000;
            background-color: #264f78;
            padding: 0;
            padding-bottom: 6px;
            transition: 0.1s ease-in-out;
        }

        #closeLeaderboardButton:hover {
            background-color: #2d5a88;
        }

        #closeLeaderboardButton:active {
            padding-bottom: 0 !important;
            transform: translateY(6px);
        }

        #nameInputSection {
            margin-bottom: 20px;
            padding: 20px;
            background: linear-gradient(to bottom, rgba(42, 42, 42, 0.5), rgba(32, 32, 32, 0.5));
            border: 1px solid rgba(74, 126, 168, 0.3);
            border-radius: 8px;
        }

        #nameInputLabel {
            font-size: 16px;
            color: #ccc;
            margin-bottom: 10px;
        }

        #playerNameInput {
            width: 100%;
            padding: 10px;
            background: rgba(15, 15, 15, 0.8);
            border: 2px solid #3a3a3a;
            border-radius: 6px;
            color: #fff;
            font-size: 16px;
            font-family: 'Roboto', sans-serif;
            margin-bottom: 10px;
        }

        #playerNameInput:focus {
            outline: none;
            border-color: #4a7ea8;
            box-shadow: 0 0 8px rgba(74, 126, 168, 0.3);
        }

        #submitNameButton {
            cursor: pointer;
            border: 3px solid #000;
            background-color: #264f78;
            padding: 0;
            padding-bottom: 6px;
            transition: 0.1s ease-in-out;
        }

        #submitNameButton:hover {
            background-color: #2d5a88;
        }

        #submitNameButton:active {
            padding-bottom: 0 !important;
            transform: translateY(6px);
        }

        .newHighScore {
            animation: celebration 0.5s ease-in-out;
            color: #ffd700 !important;
            text-shadow: 0 0 20px rgba(255, 215, 0, 0.8) !important;
        }

        @keyframes celebration {
            0%, 100% { transform: scale(1) rotate(0deg); }
            25% { transform: scale(1.2) rotate(-5deg); }
            75% { transform: scale(1.2) rotate(5deg); }
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <div id="gameTitle">üêç LADD SNAKE üêç</div>
        
        <div id="scoreBoard">
            <div class="scoreItem">
                <div class="scoreLabel">Score</div>
                <div class="scoreValue" id="score">0</div>
            </div>
            <div class="scoreItem">
                <div class="scoreLabel">High Score</div>
                <div class="scoreValue" id="highScore">0</div>
            </div>
            <div class="scoreItem">
                <div class="scoreLabel">Speed</div>
                <div class="scoreValue" id="speed">1</div>
            </div>
        </div>

        <canvas id="gameCanvas" width="600" height="600"></canvas>

        <div id="instructions">
            Use <strong>Arrow Keys</strong> or <strong>WASD</strong> to control the snake<br>
            Eat the golden Ladds to grow! üç™
        </div>

        <div id="leaderboardButton">
            <div class="button-inner">üèÜ View Leaderboard</div>
        </div>
    </div>

    <div id="gameOverScreen">
        <div id="gameOverContent">
            <div id="gameOverTitle">GAME OVER!</div>
            <div id="finalScore">Final Score: <span id="finalScoreValue">0</span></div>
            <div id="highScoreDisplay">High Score: <span id="highScoreValue">0</span></div>
            <div id="restartButton">
                <div class="button-inner">Play Again</div>
            </div>
        </div>
    </div>

    <div id="leaderboardScreen">
        <div id="leaderboardContent">
            <div id="leaderboardTitle">üèÜ LEADERBOARD üèÜ</div>
            <div id="nameInputSection" style="display: none;">
                <div id="nameInputLabel">Enter your name for the leaderboard:</div>
                <input type="text" id="playerNameInput" maxlength="20" placeholder="Your Name">
                <div id="submitNameButton">
                    <div class="button-inner">Submit Score</div>
                </div>
            </div>
            <div id="leaderboardList"></div>
            <div id="closeLeaderboardButton">
                <div class="button-inner">Close</div>
            </div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        
        // Game constants
        const GRID_SIZE = 20;
        const CELL_SIZE = canvas.width / GRID_SIZE;
        const MOVE_INTERVAL = 150; // Time between grid movements in ms
        
        // Load Ladd image
        const laddImage = new Image();
        laddImage.src = 'https://github.com/westval/cookie-clicker-assets/blob/main/image-removebg-preview.png?raw=true';
        
        // Game state
        let snake = [{ x: 10, y: 10 }];
        let direction = { x: 1, y: 0 };
        let nextDirection = { x: 1, y: 0 };
        let food = { x: 15, y: 15 };
        let score = 0;
        let highScore = parseInt(localStorage.getItem('laddSnakeHighScore')) || 0;
        let moveSpeed = MOVE_INTERVAL;
        let lastMoveTime = 0;
        let moveProgress = 0; // 0 to 1, for smooth interpolation
        let isGameOver = false;
        let animationFrameId = null;
        let currentGameScore = 0;
        let pendingLeaderboardEntry = false;
        
        // Leaderboard system
        function getLeaderboard() {
            const data = localStorage.getItem('laddSnakeLeaderboard');
            return data ? JSON.parse(data) : [];
        }
        
        function saveLeaderboard(leaderboard) {
            localStorage.setItem('laddSnakeLeaderboard', JSON.stringify(leaderboard));
        }
        
        function addToLeaderboard(name, score) {
            let leaderboard = getLeaderboard();
            leaderboard.push({ name: name, score: score, date: Date.now() });
            leaderboard.sort((a, b) => b.score - a.score);
            leaderboard = leaderboard.slice(0, 10); // Keep top 10
            saveLeaderboard(leaderboard);
            return leaderboard;
        }
        
        function isTopScore(score) {
            const leaderboard = getLeaderboard();
            return leaderboard.length < 10 || score > leaderboard[leaderboard.length - 1].score;
        }
        
        function showLeaderboard(highlightScore = null) {
            const leaderboard = getLeaderboard();
            const listContainer = document.getElementById('leaderboardList');
            listContainer.innerHTML = '';
            
            if (leaderboard.length === 0) {
                listContainer.innerHTML = '<div style="text-align: center; color: #888; padding: 20px;">No scores yet! Be the first!</div>';
            } else {
                leaderboard.forEach((entry, index) => {
                    const div = document.createElement('div');
                    div.className = 'leaderboardEntry';
                    if (index < 3) div.classList.add('top3');
                    if (highlightScore !== null && entry.score === highlightScore && entry.date === highlightScore.date) {
                        div.classList.add('currentPlayer');
                    }
                    
                    const medals = ['ü•á', 'ü•à', 'ü•â'];
                    const rankText = index < 3 ? medals[index] : `${index + 1}.`;
                    
                    div.innerHTML = `
                        <div class="leaderboardRank">${rankText}</div>
                        <div class="leaderboardName">${escapeHtml(entry.name)}</div>
                        <div class="leaderboardScore">${entry.score}</div>
                    `;
                    listContainer.appendChild(div);
                });
            }
            
            document.getElementById('leaderboardScreen').style.display = 'flex';
        }
        
        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }
        
        // Update high score display
        document.getElementById('highScore').textContent = highScore;
        
        // Input handling
        let keys = {};
        document.addEventListener('keydown', (e) => {
            const key = e.key.toLowerCase(); // Normalize to lowercase
            keys[key] = true;
            
            // Prevent default for arrow keys and WASD
            if (['arrowup', 'arrowdown', 'arrowleft', 'arrowright', 'w', 'a', 's', 'd'].includes(key)) {
                e.preventDefault();
            }
            
            // Handle direction changes (prevent 180-degree turns)
            if ((key === 'arrowup' || key === 'w') && direction.y === 0) {
                nextDirection = { x: 0, y: -1 };
            } else if ((key === 'arrowdown' || key === 's') && direction.y === 0) {
                nextDirection = { x: 0, y: 1 };
            } else if ((key === 'arrowleft' || key === 'a') && direction.x === 0) {
                nextDirection = { x: -1, y: 0 };
            } else if ((key === 'arrowright' || key === 'd') && direction.x === 0) {
                nextDirection = { x: 1, y: 0 };
            }
        });
        
        document.addEventListener('keyup', (e) => {
            const key = e.key.toLowerCase();
            keys[key] = false;
        });
        
        // Spawn food at random location
        function spawnFood() {
            let newFood;
            let isOnSnake;
            
            do {
                newFood = {
                    x: Math.floor(Math.random() * GRID_SIZE),
                    y: Math.floor(Math.random() * GRID_SIZE)
                };
                
                isOnSnake = snake.some(segment => 
                    segment.x === newFood.x && segment.y === newFood.y
                );
            } while (isOnSnake);
            
            food = newFood;
        }
        
        // Draw game with smooth interpolation
        function draw() {
            // Clear canvas
            ctx.fillStyle = '#0f0f0f';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Draw subtle grid
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.03)';
            ctx.lineWidth = 1;
            for (let i = 0; i <= GRID_SIZE; i++) {
                ctx.beginPath();
                ctx.moveTo(i * CELL_SIZE, 0);
                ctx.lineTo(i * CELL_SIZE, canvas.height);
                ctx.stroke();
                
                ctx.beginPath();
                ctx.moveTo(0, i * CELL_SIZE);
                ctx.lineTo(canvas.width, i * CELL_SIZE);
                ctx.stroke();
            }
            
            // Draw snake with smooth interpolation
            snake.forEach((segment, index) => {
                let drawX = segment.x * CELL_SIZE;
                let drawY = segment.y * CELL_SIZE;
                
                // Interpolate head position for smooth movement
                if (index === 0 && moveProgress < 1 && !isGameOver) {
                    const prevX = segment.x - direction.x;
                    const prevY = segment.y - direction.y;
                    
                    drawX = (prevX + direction.x * moveProgress) * CELL_SIZE;
                    drawY = (prevY + direction.y * moveProgress) * CELL_SIZE;
                }
                
                // Interpolate body segments to follow head smoothly
                if (index > 0 && moveProgress < 1 && !isGameOver) {
                    const nextSegment = snake[index - 1];
                    const dx = nextSegment.x - segment.x;
                    const dy = nextSegment.y - segment.y;
                    
                    if (Math.abs(dx) <= 1 && Math.abs(dy) <= 1) {
                        drawX = (segment.x + dx * moveProgress) * CELL_SIZE;
                        drawY = (segment.y + dy * moveProgress) * CELL_SIZE;
                    }
                }
                
                if (laddImage.complete) {
                    // Draw Ladd image with smooth shadow
                    ctx.save();
                    
                    // Add subtle shadow
                    ctx.shadowBlur = 8;
                    ctx.shadowColor = 'rgba(0, 0, 0, 0.5)';
                    ctx.shadowOffsetY = 2;
                    
                    ctx.beginPath();
                    ctx.arc(drawX + CELL_SIZE/2, drawY + CELL_SIZE/2, CELL_SIZE/2 - 2, 0, Math.PI * 2);
                    ctx.clip();
                    ctx.drawImage(laddImage, drawX + 2, drawY + 2, CELL_SIZE - 4, CELL_SIZE - 4);
                    ctx.restore();
                    
                    // Add glow to head
                    if (index === 0) {
                        ctx.strokeStyle = '#4CAF50';
                        ctx.lineWidth = 2;
                        ctx.shadowBlur = 12;
                        ctx.shadowColor = '#4CAF50';
                        ctx.beginPath();
                        ctx.arc(drawX + CELL_SIZE/2, drawY + CELL_SIZE/2, CELL_SIZE/2 - 1, 0, Math.PI * 2);
                        ctx.stroke();
                        ctx.shadowBlur = 0;
                    }
                } else {
                    // Fallback if image not loaded
                    ctx.fillStyle = index === 0 ? '#4CAF50' : '#66BB6A';
                    ctx.fillRect(drawX + 2, drawY + 2, CELL_SIZE - 4, CELL_SIZE - 4);
                }
            });
            
            // Draw food (golden Ladd) with pulsing animation
            const foodX = food.x * CELL_SIZE;
            const foodY = food.y * CELL_SIZE;
            const pulseScale = 1 + Math.sin(Date.now() / 200) * 0.1;
            
            if (laddImage.complete) {
                ctx.save();
                
                // Pulsing golden glow
                ctx.shadowBlur = 25;
                ctx.shadowColor = '#FFD700';
                
                // Scale for pulse effect
                const scaledSize = CELL_SIZE * pulseScale;
                const offset = (CELL_SIZE - scaledSize) / 2;
                
                ctx.beginPath();
                ctx.arc(foodX + CELL_SIZE/2, foodY + CELL_SIZE/2, scaledSize/2 - 2, 0, Math.PI * 2);
                ctx.clip();
                
                // Draw golden-tinted Ladd
                ctx.filter = 'brightness(1.8) saturate(2.5) hue-rotate(20deg)';
                ctx.drawImage(laddImage, foodX + offset + 2, foodY + offset + 2, scaledSize - 4, scaledSize - 4);
                ctx.restore();
                
                ctx.shadowBlur = 0;
                
                // Add sparkle border
                ctx.strokeStyle = '#FFD700';
                ctx.lineWidth = 2;
                ctx.shadowBlur = 15;
                ctx.shadowColor = '#FFD700';
                ctx.beginPath();
                ctx.arc(foodX + CELL_SIZE/2, foodY + CELL_SIZE/2, scaledSize/2 - 1, 0, Math.PI * 2);
                ctx.stroke();
                ctx.shadowBlur = 0;
            } else {
                // Fallback
                ctx.fillStyle = '#FFD700';
                ctx.fillRect(foodX + 2, foodY + 2, CELL_SIZE - 4, CELL_SIZE - 4);
            }
        }
        
        // Main game loop using requestAnimationFrame for smooth 60fps
        function gameLoop(currentTime) {
            if (isGameOver) return;
            
            // Calculate time since last move
            const timeSinceMove = currentTime - lastMoveTime;
            moveProgress = Math.min(timeSinceMove / moveSpeed, 1);
            
            // Move snake when progress reaches 1
            if (moveProgress >= 1) {
                update();
                lastMoveTime = currentTime;
                moveProgress = 0;
            }
            
            // Always draw for smooth interpolation
            draw();
            
            // Continue loop
            animationFrameId = requestAnimationFrame(gameLoop);
        }
        
        // Update game state (called at discrete intervals)
        function update() {
            // Update direction
            direction = { ...nextDirection };
            
            // Calculate new head position
            const head = { ...snake[0] };
            head.x += direction.x;
            head.y += direction.y;
            
            // Check wall collision
            if (head.x < 0 || head.x >= GRID_SIZE || head.y < 0 || head.y >= GRID_SIZE) {
                gameOver();
                return;
            }
            
            // Check self collision
            if (snake.some(segment => segment.x === head.x && segment.y === head.y)) {
                gameOver();
                return;
            }
            
            // Add new head
            snake.unshift(head);
            
            // Check food collision
            if (head.x === food.x && head.y === food.y) {
                score++;
                updateScore();
                spawnFood();
                
                // Increase speed every 5 points (decrease moveSpeed)
                if (score % 5 === 0 && moveSpeed > 50) {
                    moveSpeed -= 15;
                    updateSpeedDisplay();
                }
                
                // Play sound
                playEatSound();
            } else {
                // Remove tail if no food eaten
                snake.pop();
            }
        }
        
        // Update score display
        function updateScore() {
            document.getElementById('score').textContent = score;
            
            if (score > highScore) {
                highScore = score;
                document.getElementById('highScore').textContent = highScore;
                document.getElementById('highScore').classList.add('newHighScore');
                setTimeout(() => {
                    document.getElementById('highScore').classList.remove('newHighScore');
                }, 500);
                localStorage.setItem('laddSnakeHighScore', highScore);
            }
        }
        
        // Update speed display
        function updateSpeedDisplay() {
            const speedLevel = Math.floor((MOVE_INTERVAL - moveSpeed) / 15) + 1;
            document.getElementById('speed').textContent = speedLevel;
        }
        
        // Game over
        function gameOver() {
            isGameOver = true;
            if (animationFrameId) {
                cancelAnimationFrame(animationFrameId);
            }
            
            currentGameScore = score;
            
            document.getElementById('finalScoreValue').textContent = score;
            document.getElementById('highScoreValue').textContent = highScore;
            
            // Check if player made the leaderboard
            if (isTopScore(score)) {
                pendingLeaderboardEntry = true;
                document.getElementById('nameInputSection').style.display = 'block';
                document.getElementById('playerNameInput').value = '';
                document.getElementById('playerNameInput').focus();
            } else {
                pendingLeaderboardEntry = false;
                document.getElementById('nameInputSection').style.display = 'none';
            }
            
            document.getElementById('gameOverScreen').style.display = 'flex';
            
            playGameOverSound();
        }
        
        // Restart game
        function restartGame() {
            snake = [{ x: 10, y: 10 }];
            direction = { x: 1, y: 0 };
            nextDirection = { x: 1, y: 0 };
            score = 0;
            moveSpeed = MOVE_INTERVAL;
            isGameOver = false;
            lastMoveTime = performance.now();
            moveProgress = 0;
            
            document.getElementById('score').textContent = 0;
            document.getElementById('speed').textContent = 1;
            document.getElementById('gameOverScreen').style.display = 'none';
            
            spawnFood();
            
            if (animationFrameId) {
                cancelAnimationFrame(animationFrameId);
            }
            animationFrameId = requestAnimationFrame(gameLoop);
        }
        
        // Sound effects
        function playEatSound() {
            const audioContext = new (window.AudioContext || window.webkitAudioContext)();
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();
            
            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);
            
            oscillator.frequency.value = 800;
            oscillator.type = 'sine';
            
            gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.1);
            
            oscillator.start(audioContext.currentTime);
            oscillator.stop(audioContext.currentTime + 0.1);
        }
        
        function playGameOverSound() {
            const audioContext = new (window.AudioContext || window.webkitAudioContext)();
            
            [400, 300, 200].forEach((freq, index) => {
                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();
                
                oscillator.connect(gainNode);
                gainNode.connect(audioContext.destination);
                
                oscillator.frequency.value = freq;
                oscillator.type = 'triangle';
                
                const startTime = audioContext.currentTime + (index * 0.15);
                gainNode.gain.setValueAtTime(0.2, startTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, startTime + 0.2);
                
                oscillator.start(startTime);
                oscillator.stop(startTime + 0.2);
            });
        }
        
        // Event listeners
        document.getElementById('restartButton').addEventListener('click', restartGame);
        
        document.getElementById('leaderboardButton').addEventListener('click', () => {
            showLeaderboard();
        });
        
        document.getElementById('closeLeaderboardButton').addEventListener('click', () => {
            document.getElementById('leaderboardScreen').style.display = 'none';
        });
        
        document.getElementById('submitNameButton').addEventListener('click', () => {
            const name = document.getElementById('playerNameInput').value.trim();
            if (name) {
                const newEntry = addToLeaderboard(name, currentGameScore);
                document.getElementById('nameInputSection').style.display = 'none';
                showLeaderboard(currentGameScore);
                pendingLeaderboardEntry = false;
            }
        });
        
        document.getElementById('playerNameInput').addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                document.getElementById('submitNameButton').click();
            }
        });
        
        // Initialize game
        function init() {
            // Wait for image to load
            laddImage.onload = () => {
                spawnFood();
                draw();
                lastMoveTime = performance.now();
                animationFrameId = requestAnimationFrame(gameLoop);
            };
            
            // Start anyway if image fails to load
            setTimeout(() => {
                if (!laddImage.complete) {
                    console.log('Image loading slowly, starting anyway...');
                    spawnFood();
                    draw();
                    lastMoveTime = performance.now();
                    animationFrameId = requestAnimationFrame(gameLoop);
                }
            }, 1000);
        }
        
        init();
    </script>
</body>
</html>
